# 1. Утилита обработки видео с использованием YOLOv10

detect_segments.py

Утилита предназначена для обработки видеофайлов с использованием модели YOLOv10 для обнаружения объектов. Извлекает кадры из видео, применяет детекцию объектов и сохраняет результаты.

## Основные функции

- Извлечение кадров из видео с заданной частотой
- Обнаружение объектов на кадрах с помощью YOLOv10
- Фильтрация обнаруженных объектов по классу и уверенности
- Сохранение результатов в виде сегментов видео и детальной информации
- Опциональное сохранение обработанных кадров и обрезанных изображений объектов

## Параметры

- `--source`: Папка с исходными видеофайлами (по умолчанию: "c:\video")
- `--fps`: Частота извлечения кадров (кадры в секунду, по умолчанию: 0.1)
- `--device`: Устройство для обработки (cpu или cuda, по умолчанию: cpu)
- `--segments`: Файл для сохранения результатов сегментов (по умолчанию: segments.txt)
- `--results`: Файл для сохранения детальных результатов (по умолчанию: results.json)
- `--class_id`: ID класса YOLO для фильтрации объектов (по умолчанию: 0)
- `--save_images`: Флаг для сохранения обработанных кадров
- `--save_boxes`: Флаг для сохранения обрезанных областей с обнаруженными объектами
- `--model_weights`: Путь к весам модели YOLOv10 (по умолчанию: yolov10s.pt)
- `--confidence`: Минимальный порог уверенности для фильтрации объектов (по умолчанию: 0.7)
- `--border`: Процент увеличения границы вокруг обнаруженного объекта (по умолчанию: 0.20)
- `--gap`: Допустимый промежуток между кадрами для сегментации, в секундах (по умолчанию: 20)

Утилита обрабатывает все видеофайлы в указанной папке, применяет детекцию объектов и сохраняет результаты в заданные файлы.

## Использование

```bash
python detect_segments.py --source d:/video/new --fps 0.1 --device cuda --segments segments.txt --results details.json --class_id 0 --model_weights yolov10s.pt --confidence 0.7 --border 0.20 --gap 20
```

# 2. Утилита обработки видеосегментов

process_segments.py

Эта утилита предназначена для обработки и фильтрации данных сегментов видео, полученных после детекции объектов. Она читает файл с информацией о сегментах, фильтрует их по заданной минимальной длительности и создает новый файл с отфильтрованными данными.

## Основные функции

- Чтение файла с информацией о сегментах видео
- Фильтрация сегментов по минимальной длительности
- Создание нового файла с отфильтрованными сегментами
- Перемещение файлов без подходящих сегментов в отдельную папку

## Параметры

- `--segments`: Путь к исходному файлу с сегментами (по умолчанию: "segments.txt")
- `--delete_folder`: Папка для перемещения файлов без подходящих сегментов (по умолчанию: "delete_files/")
- `--newsegments`: Файл для записи отфильтрованных сегментов (по умолчанию: "segments_split.txt")
- `--mintime`: Минимальная длительность сегмента в секундах (по умолчанию: 300)

## Использование

```bash
python process_segments.py --segments segments.txt --delete_folder d:/video/deleted --newsegments segments_split.txt --mintime 300
```

Утилита обрабатывает входной файл с сегментами, удаляет сегменты короче указанной длительности, перемещает файлы без подходящих сегментов в указанную папку и сохраняет результаты в новый файл.

# 3. Утилита для извлечения видеосегментов

extract_segments.py

Эта утилита предназначена для быстрого извлечения сегментов из видеофайлов на основе предварительно обработанных данных детекции объектов. Она читает информацию о сегментах из текстового файла, извлекает соответствующие фрагменты видео и сохраняет их как отдельные файлы.

## Основные функции

- Чтение информации о видеосегментах из текстового файла
- Извлечение указанных сегментов из исходных видеофайлов
- Сохранение извлеченных сегментов как отдельных видеофайлов
- Возможность указать целевую папку для сохранения результатов

## Параметры

- `--segments`: Путь к файлу с информацией об обработанных сегментах (по умолчанию: "segments_split.txt")
- `--target_folder`: Путь к папке для сохранения извлеченных видеосегментов (необязательный параметр)

## Формат файла с сегментами

Файл с сегментами должен иметь следующий формат:

```txt
"путь_к_видео",начало1:длительность1,начало2:длительность2,...
```

Например:

```txt
"c:\videos\video1.mp4",10:30,50:20,100:45
```

Утилита обрабатывает все видеофайлы, указанные в файле сегментов, извлекает соответствующие фрагменты и сохраняет их в исходной или указанной целевой папке.

## Пример использования

```bash
python extract_segments.py --segments segments_split.txt --target_folder d:/video/clips
```

Вот пример использования программы VideoFileSorter для README.md на русском языке:

# 4. Сортировщик видеофайлов

`sort_clips.py` - это утилита для организации видеофайлов по папкам на основе информации о камере и дате, извлеченной из имен файлов.

## Возможности

- Извлекает информацию о камере и дате из имен видеофайлов
- Создает структуру папок на основе камеры и даты
- Перемещает видеофайлы в соответствующие папки
- Поддерживает аргументы командной строки для гибкого использования

## Использование

```bash
python sort_clips.py --source_folder d:/video/clips --target_folder d:/video/sorted
```

## Параметры

- `--source_folder`: Путь к папке с несортированными видеофайлами (обязательный)
- `--target_folder`: Путь к папке, куда будут перемещены отсортированные файлы (обязательный)

## Пример

Предположим, у вас есть видеофайлы в формате `cam-901-2023-05-15-120000.mp4` в папке `/video/clips`. Чтобы отсортировать эти файлы в структурированную иерархию папок, выполните:

```bash
sort_clips.py --source_folder /video/clips --target_folder /video/sorted
```

Это создаст структуру папок следующего вида:

```
/video/sorted
├── cam-901/
│   └── 2023-05-15/
│       └── cam-901-2023-05-15-120000.mp4
├── cam-1001/
│   └── 2023-05-16/
│       └── cam-1001-2023-05-16-130000.mp4
...
```

Скрипт переместит каждый видеофайл в соответствующую папку на основе номера камеры и даты, извлеченных из имени файла.

# 5. Утилита для извлечения кадров из видео

extract_frames.py

Эта утилита предназначена для извлечения кадров из видеофайлов с заданной частотой и сохранения их в виде изображений.

## Основные функции

- Обработка видеофайлов из указанной папки
- Извлечение кадров с заданной частотой
- Сохранение кадров в формате PNG
- Создание текстового файла с информацией о извлеченных кадрах
- Опциональная обработка подпапок

## Параметры

- `--source_folder`: Исходная папка с видеофайлами (по умолчанию: "d:/video/sorted")
- `--target_folder`: Папка для сохранения извлеченных кадров (по умолчанию: "d:/video/results")
- `--fps`: Частота извлечения кадров (по умолчанию: 1.0)
- `--subfolders`: Сканировать входную папку с подпапками (по умолчанию: True)

## Использование

```bash
python extract_frames.py --source_folder d:/video/sorted --target_folder d:/video/results --fps 0.02 --subfolders True
```

## Результаты

- Извлеченные кадры сохраняются в формате PNG в указанной выходной папке
- Создается файл `frames.txt` с информацией о извлеченных кадрах в формате:
  
  ```txt
  "имя_видео.mp4", "имя_видео.001.png"
  "имя_видео.mp4", "имя_видео.002.png"
  ...
  ```

Утилита обрабатывает все видеофайлы в указанной папке, извлекает кадры с заданной частотой и сохраняет результаты в выходной папке, сохраняя структуру подпапок при необходимости.

# 6. Детектор объектов на видео с использованием YOLOv10 и Microsoft Florence-2

`detect_florence.py` - это утилита для обработки видеофайлов с использованием моделей YOLOv10 и Microsoft Florence-2 для обнаружения и анализа объектов.

## Основные возможности

- Извлечение кадров из видео с заданной частотой
- Обнаружение объектов на кадрах с помощью YOLOv10
- Анализ обнаруженных объектов с использованием Microsoft Florence-2
- Фильтрация результатов по классу и уверенности
- Сохранение результатов в JSON-формате и изображений
- Создание отдельных папок для каждого обрабатываемого видео

## Параметры

- `--source_folder`: Директория с входными видеофайлами (обязательный)
- `--target_folder`: Директория для сохранения результатов (обязательный)
- `--yolo_model`: Путь к весам модели YOLO (по умолчанию: "yolov10s.pt")
- `--florence_model`: Название или путь к модели Florence (по умолчанию: "microsoft/Florence-2-large")
- `--yolo_id`: ID класса YOLO для детекции (по умолчанию: 0). Если yolo_id = -1, то детекция YOLO не используется, а для работы с florence передается все изображение.
- `--general_prompt`: Общий промпт для детекции (обязательный)
- `--class_prompts`: Промпты для классов в формате "class_id=prompt" (обязательный)
- `--device`: Устройство для вычислений (cpu или cuda, по умолчанию: "cpu")
- `--fps`: Кадров в секунду для детекции (по умолчанию: 0.1)
- `--confidence`: Минимальная уверенность для детекций YOLO (по умолчанию: 0.7)
- `--border`: Процент увеличения размера ограничивающей рамки (по умолчанию: 0.20)
- `--query`: Запрос к модели Microsoft Florence (по умолчанию: "<CAPTION_TO_PHRASE_GROUNDING>"). Возможны также "<CAPTION>", "<DETAILED_CAPTION>", "<MORE_DETAILED_CAPTION>". Если запрос не указан, модель Florence не используется.

- `--mode`: Режим обработки: video или images (по умолчанию: "images")
- `--subfolder`: Обрабатывать подпапки во входной директории (по умолчанию: True)
- `--forcemask`: Список файловых масок для принудительной обработки (например 'VID_20240627_110044.' или \*VID_20240627_110044\*)
- `--save_original`: Сохранять оригинальные изображения (по умолчанию: True)
- `--save_yolo`: Сохранять боксы из результатов YOLO (по умолчанию: False)
- `--save_boxes`: Сохранять боксы из результатов Florence (по умолчанию: False)
- `--draw_boxes`: Рисовать боксы из результатов Florence (по умолчанию: False)
- `--scale`: Масштабирование изображений перед обработкой (по умолчанию: 1)
- `--draw_yolo_boxes`: Рисовать боксы из результатов YOLO (по умолчанию: False)
- `--yolo_slice`: Количество квадратных кусков для нарезки результатов YOLO (по умолчанию: 0, -1 для автоматического определения количества)
- `--yolo_slice_overlap`: Процент перекрытия для нарезки YOLO (по умолчанию: 0.0)
- `--verbose`: Выводить отладочную информацию YOLO (по умолчанию: False)

## Использование

```bash
python detect_florence.py --source_folder c:/video/2024-05-10 --target_folder c:/video/florence --general_prompt "locate gloves on people hands" --class_prompts "0=locate gloves" "1=locate people" "2=locate hands" --mode "images" --save_boxes --device cpu
```

Программа обрабатывает все видеофайлы или изображения в указанной директории, применяет детекцию объектов с помощью YOLOv10 и анализирует результаты с использованием Microsoft Florence-2. Результаты сохраняются в отдельных папках для каждого видео или набора изображений, включая JSON-файлы с детальной информацией и изображения обнаруженных объектов.

# 7. Утилита для копирования файлов с фильтрацией

`copy_files.py`

Эта утилита предназначена для копирования файлов из одной папки в другую, игнорируя файлы, находящиеся в заданных папках, и фильтруя их по маске.

## Основные функции

- Сканирование исходной папки по заданной маске
- Игнорирование файлов, находящихся в указанных папках
- Копирование файлов в целевую папку
- Логирование копирования и пропуска файлов

## Параметры

- `--source_folder`: Путь к исходной папке (по умолчанию: "florence")
- `--target_folder`: Путь к целевой папке (по умолчанию: "florence.new")
- `--ignore_folders`: Список папок для игнорирования файлов (по умолчанию: ["florence.good", "florence.bad"])
- `--mask`: Маска для сканирования файлов (по умолчанию: "*.florence.*")

Утилита сканирует все файлы в исходной папке `--source_folder`, фильтрует их по маске `--mask` и проверяет, находятся ли эти файлы в папках из списка `--ignore_folders`. Список игнорируемых файлов загружается один раз перед началом копирования.

Файлы, которые не находятся в папках из списка `--ignore_folders`, копируются в целевую папку `--target_folder`. В процессе копирования утилита показывает, какие файлы были скопированы, а какие пропущены.

## Использование

```bash
python copy_files.py --source_folder c:/video/florence --target_folder c:/video/florence.new --ignore_folders c:/video/florence.good c:/video/florence.bad --mask *.florence.*
```

Этот пример сканирует папку `c:/video/florence` на наличие файлов, соответствующих маске `*.florence.*`, игнорирует файлы из папок `c:/video/florence.good` и `c:/video/florence.bad`, и копирует найденные файлы в папку `c:/video/florence.new`.

# 8. Утилита создания YOLO датасета

create_dataset.py

Эта утилита предназначена для создания датасета в формате YOLO из изображений и аннотаций, полученных от модели Microsoft Florence.

## Основные функции

- Чтение изображений и аннотаций из заданных папок
- Конвертация формата ограничивающих рамок из Florence в формат YOLO
- Разделение данных на тренировочный и валидационный наборы
- Сохранение изображений и аннотаций в соответствующие папки

## Параметры

- `--source_folder`: Путь к исходной папке с аннотациями и оригинальными изображениями (по умолчанию: "c:\video\florence")
- `--data_folder`: Путь к папке с отфильтрованными изображениями (по умолчанию: "c:\video\florence.good")
- `--dataset_folder`: Путь к папке для сохранения созданного датасета (по умолчанию: "c:\video\dataset")
- `--class_id`: Идентификатор класса для YOLO (по умолчанию: 0)
- `--valid`: Процент данных для валидации (по умолчанию: 20)

## Пример структуры папок

```txt
dataset/
├── train/
│   ├── images/
│   └── labels/
└── valid/
    ├── images/
    └── labels/
```

## Использование

Для запуска утилиты используйте команду:

```bash
python create_dataset.py --source_folder c:/video/florence --data_folder c:/video/florence.good --dataset_folder c:/video/dataset --class_id 0 --valid 20
```

Эта команда запустит процесс создания датасета, в ходе которого изображения и аннотации будут преобразованы и сохранены в соответствующие папки, разделенные на тренировочные и валидационные наборы.

# 9. Утилита для фильтрации и копирования файлов JSON и изображений

`filter_labels.py`

Эта утилита предназначена для поиска файлов JSON в указанной папке, фильтрации их по меткам и копирования соответствующих изображений в целевую папку.

## Основные функции

- Сканирование указанной папки на наличие файлов JSON
- Фильтрация меток в JSON файлах по заданным критериям
- Копирование изображений, соответствующих отфильтрованным меткам, в целевую папку

## Параметры

- `--source_folder`: Путь к исходной папке с файлами JSON и изображениями (по умолчанию: "florence")
- `--target_folder`: Путь к папке для сохранения скопированных изображений (по умолчанию: "florence.new")
- `--label_filter`: Список фильтров для меток (по умолчанию: ["text label", "inscription"])
- `--extract`: Вырезать изображения по bounding box (по умолчанию: False)

Утилита сканирует все файлы JSON в исходной папке , проверяет метки в JSON файлах и, если метка соответствует любому из значений, заданных в фильтре, копирует соответствующее изображение в целевую папку.

## Использование

```bash
python filter_labels.py --source_folder c:/video/labels.florence --target_folder c:/video/labels.new --label_filter "text label" "inscription" --extract
```

Этот пример сканирует папку `c:/video/florence` на наличие файлов JSON, фильтрует метки в JSON файлах по значениям "text label" и "inscription", и копирует изображения, соответствующие отфильтрованным меткам, в папку `c:/video/florence.new`.

## 10. Утилита для перемещения изображений по размеру и построения гистограмм

`sort_images.py`

Эта утилита предназначена для сканирования папки с изображениями, построения гистограмм их ширины и высоты, и перемещения изображений в целевую папку, если их размеры не соответствуют заданным критериям.

## Основные функции

- Сканирование указанной папки для изображений
- Построение гистограмм ширины и высоты изображений
- Перемещение изображений в целевую папку, если их размеры не соответствуют заданным критериям

## Параметры

- `--source_folder`: Путь к исходной папке с изображениями (по умолчанию: "~/data/source")
- `--target_folder`: Путь к целевой папке для перемещения изображений (по умолчанию: "~/data/target")
- `--min_height`: Минимальная высота изображений для перемещения (по умолчанию: None)
- `--max_height`: Максимальная высота изображений для перемещения (по умолчанию: None)
- `--min_width`: Минимальная ширина изображений для перемещения (по умолчанию: None)
- `--max_width`: Максимальная ширина изображений для перемещения (по умолчанию: None)

## Пример использования

```bash
python sort_images.py --source_folder ~/data/source --target_folder ~/data/target --min_height 200 --max_height 800 --min_width 200 --max_width 800
```

Этот пример сканирует папку `~/data/source` на наличие изображений, строит гистограммы их ширины и высоты, и перемещает изображения в папку `~/data/target`, если их размеры не соответствуют заданным критериям.

## Результаты

- Изображения, не соответствующие заданным размерам, будут перемещены в целевую папку.
- Гистограммы ширины и высоты изображений будут сохранены в файлы `width_histogram.png` и `height_histogram.png` соответственно.

Этот скрипт помогает автоматизировать процесс сортировки изображений по их размерам, а также предоставляет наглядное представление о распределении размеров изображений в указанной папке.

# 11. Утилита для детекции объектов с использованием YOLO

`detect_yolo.py`

Эта утилита предназначена для обработки изображений с использованием модели YOLO для обнаружения объектов. Она позволяет сохранять результаты детекции, включая вырезанные области с обнаруженными объектами, и рисовать ограничивающие рамки на изображениях.

## Основные функции

- Обнаружение объектов на изображениях с помощью YOLO
- Сохранение результатов детекции в JSON формате
- Опциональное сохранение вырезанных областей с обнаруженными объектами
- Опциональное рисование ограничивающих рамок на изображениях
- Поддержка обработки изображений в подпапках
- Использование каскада моделей для улучшения точности детекции

## Параметры

- `--source_folder`: Папка с исходными изображениями (по умолчанию: "~/data/video")
- `--target_folder`: Папка для сохранения результатов (по умолчанию: "~/data/output")
- `--models`: Файлы моделей YOLO (по умолчанию: ["detectprofile.pt", "detectlabel.pt"])
- `--model_path`: Путь к файлам моделей YOLO (по умолчанию: "~/models")
- `--classes`: Классы YOLO для каждой модели (по умолчанию: [[0], [0]])
- `--subfolder`: Включать подпапки (по умолчанию: False)
- `--save_boxes`: Сохранять вырезанные боксы для каждой модели (по умолчанию: [False, True])
- `--draw_boxes`: Рисовать ограничивающие рамки на изображениях для каждой модели (по умолчанию: [True, True])
- `--save_json`: Сохранять результаты в JSON для каждой модели (по умолчанию: [False, True])
- `--format`: Формат для сохранения изображений (по умолчанию: "png")
- `--extensions`: Расширения файлов для обработки (по умолчанию: ["*.jpg", "*.jpeg", "*.png"])
- `--borders`: Процент увеличения размера ограничивающей рамки для каждой модели (по умолчанию: [0.0, 20.0])
- `--confidiences`: Минимальная уверенность для каждой модели (по умолчанию: [0.5, 0.7])
- `--verbose`: Подробный вывод (по умолчанию: False)

## Каскадное использование моделей

Утилита `detect_yolo.py` поддерживает каскадное использование моделей для последовательного улучшения результатов детекции. Это означает, что детекция объектов выполняется сначала с использованием первой модели, затем на основании результатов первой модели выполняется детекция с использованием второй модели, и так далее. Это позволяет улучшить точность детекции за счет постепенного уточнения обнаруженных объектов.

### Пример работы каскада моделей

1. **Первая модель** (`detectprofile.pt`):
   - На первом этапе детекции используется первая модель для обнаружения объектов на изображении.
   - Выходные данные первой модели включают координаты ограничивающих рамок и метаданные детекции.

2. **Вторая модель** (`detectlabel.pt`):
   - Для каждой ограничивающей рамки, обнаруженной первой моделью, создается новое изображение (кроп).
   - Эти кропы затем подаются на вход второй модели, которая выполняет дополнительную детекцию и классификацию внутри этих рамок.
   - Результаты второй модели уточняют и дополняют первоначальные данные.

## Пример использования

```bash
python detect_yolo.py --source_folder ~/data/input --target_folder ~/data/output --models detectprofile.pt detectlabel.pt --model_path ~/models --classes 0 1 --subfolder --save_boxes --draw_boxes --save_json --verbose --format png --extensions "*.jpg" "*.jpeg" "*.png" --borders 0.0 20.0 --confidiences 0.5 0.7
```

## Результаты

После обработки изображений утилита сохранит результаты в указанную папку. Формат и структура сохраненных файлов зависят от параметров, использованных при запуске.

## Примеры результатов

1. **Оригинальные изображения с нарисованными рамками:**
   Если параметр `--draw_boxes` включен, изображения будут сохранены с нарисованными ограничивающими рамками вокруг обнаруженных объектов.

2. **Вырезанные области объектов:**
   Если параметр `--save_boxes` включен, вырезанные области с обнаруженными объектами будут сохранены как отдельные изображения.

3. **JSON файлы с метаданными:**
   Для каждого обработанного изображения будет создан JSON файл, содержащий метаданные детекции, такие как координаты ограничивающих рамок, уверенность модели и класс объекта.

## Пример JSON файла

```json
{
    "file": "~/data/input/image1.jpg",
    "width": 1024,
    "height": 768,
    "yolo": [
        {
            "class_id": 0,
            "confidence": 0.85,
            "bbox": [100, 150, 400, 450]
        },
        {
            "class_id": 1,
            "confidence": 0.78,
            "bbox": [500, 200, 900, 600]
        }
    ]
}
```

Этот JSON файл содержит информацию о всех обнаруженных объектах на изображении, включая класс объекта, уверенность модели и координаты ограничивающей рамки.

# 12. Утилита для распознавания текста с изображений

`detect_easyocr.py` - это утилита для распознавания текста на изображениях с использованием библиотеки EasyOCR. Утилита позволяет сохранять результаты распознавания в JSON-файлах, рисовать рамки вокруг обнаруженного текста и извлекать текстовые области.

## Основные функции

- Распознавание текста на изображениях с помощью EasyOCR
- Сохранение результатов распознавания в формате JSON
- Опциональное рисование рамок вокруг обнаруженного текста
- Опциональное извлечение текстовых областей в отдельные изображения
- Засекание времени выполнения OCR и запись его в JSON

## Параметры

- `--source_folder`: Папка с исходными изображениями (по умолчанию: "~/data/source/")
- `--target_folder`: Папка для сохранения результатов (по умолчанию: "~/data/target/")
- `--draw_boxes`: Рисовать рамки вокруг обнаруженного текста (по умолчанию: False)
- `--save_boxes`: Извлекать и сохранять боксы с текстом в JSON (по умолчанию: False)
- `--width_ths`: Порог ширины для EasyOCR (по умолчанию: 0.01)
- `--add_margin`: Порог отступов вокруг текста для EasyOCR (по умолчанию: 0.05)
- `--measure_time`: Засекать время выполнения EasyOCR и записывать его в JSON (по умолчанию: False)
- `--confidence`: Минимальный уровень уверенности для сохранения результатов (по умолчанию: 0.4)

## Использование

```bash
python detect_easyocr.py --source_folder ~/data/source --target_folder ~/data/target --draw_boxes --width_ths 0.01 --add_margin 0.05 --save_boxes --measure_time --confidence 0.5
```

## Пример

Предположим, у вас есть изображения в папке `~/data/source`, и вы хотите распознать текст на этих изображениях с минимальным уровнем уверенности 0.5, рисовать рамки вокруг обнаруженного текста, извлекать текстовые области в отдельные изображения и записывать время выполнения OCR. Выполните следующую команду:

```bash
python detect_easyocr.py --source_folder ~/data/source --target_folder ~/data/target --draw_boxes --width_ths 0.01 --add_margin 0.05 --save_boxes --measure_time --confidence 0.5
```

Эта команда запустит процесс распознавания текста на изображениях в папке `~/data/source`, сохранит результаты в папке `~/data/target`, нарисует рамки вокруг обнаруженного текста, извлечет текстовые области в отдельные изображения и запишет время выполнения OCR в JSON.

## Пример JSON файла

```json
{
    "width": 1024,
    "height": 768,
    "easyocr": [
        {
            "text": "Пример текста",
            "confidence": 0.85,
            "bbox": [100, 150, 400, 450]
        }
    ],
    "file": "~/data/source/image1.jpg",
    "time": 0.75
}
```

Этот JSON файл содержит информацию о распознанном тексте, включая координаты ограничивающей рамки, уверенность модели и время выполнения OCR.
